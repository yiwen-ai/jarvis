pub struct RawJSONArray {
    chars: Vec<char>,
    offset: usize,
    result: Vec<char>,
}

impl RawJSONArray {
    pub fn new(s: &str) -> Self {
        let s = s.trim();
        let cap = s.len();
        let chars: Vec<char> = s.chars().collect();
        Self {
            chars,
            offset: 0,
            result: Vec::with_capacity(cap),
        }
    }

    // ç”¨äºå°è¯•ä¿®å¤ OpenAI translate è¿”å›çš„ JSON String æ— æ³•è§£æ Vec<Vec<String>> çš„é—®é¢˜
    pub fn fix_me(mut self) -> Result<String, String> {
        self.skip_space();
        if self.offset >= self.chars.len() {
            return Err("no token to scan".to_string());
        }

        match self.chars[self.offset] {
            '[' => {
                if let Some(s) = self.array() {
                    return Err(s);
                }
            }
            _ => {
                return Err(format!(
                    "unknown token `{}` to start fix_me",
                    self.chars[self.offset]
                ));
            }
        }

        self.skip_space();
        if self.offset < self.chars.len() {
            return Err(format!(
                "extraneous data exist: `{}`",
                self.chars[self.offset]
            ));
        }

        Ok(String::from_iter(&self.result))
    }

    fn skip_space(&mut self) {
        while self.offset < self.chars.len() {
            if self.chars[self.offset].is_whitespace() || self.chars[self.offset].is_control() {
                self.offset += 1;
            } else {
                break;
            }
        }
    }

    fn skip_space_v(&self) -> usize {
        let mut offset = self.offset;
        while offset < self.chars.len() {
            if self.chars[offset].is_whitespace() || self.chars[self.offset].is_control() {
                offset += 1;
            } else {
                break;
            }
        }
        return offset;
    }

    // return error message if failed
    fn array(&mut self) -> Option<String> {
        self.result.push('[');
        self.offset += 1;
        self.skip_space();

        if self.offset < self.chars.len() && self.chars[self.offset] == ']' {
            self.result.push(']');
            self.offset += 1;
            return None;
        }

        while self.offset < self.chars.len() {
            match self.chars[self.offset] {
                '[' => {
                    if let Some(s) = self.array() {
                        return Some(s);
                    }
                }
                '"' => {
                    if let Some(s) = self.text() {
                        return Some(s);
                    }
                }
                _ => {
                    // case: miss a '"'
                    if self.result.last() == Some(&',') && self.result[self.result.len() - 2] == '"'
                    {
                        self.offset -= 1;
                        if let Some(s) = self.text() {
                            return Some(s);
                        }
                    } else {
                        return Some(format!(
                            "unsupport token `{}{}` at {} to start in array",
                            self.chars[self.offset - 1],
                            self.chars[self.offset],
                            self.offset
                        ));
                    }
                }
            }

            self.skip_space();
            if self.offset >= self.chars.len() {
                self.result.push(']');
                self.offset += 1;
                return None;
            }

            match self.chars[self.offset] {
                ',' => {
                    self.offset += 1;
                    self.skip_space();
                    if self.offset < self.chars.len() && self.chars[self.offset] == ']' {
                        self.result.push(']');
                        self.offset += 1;
                        return None;
                    } else {
                        self.result.push(',');
                    }
                }
                ']' => {
                    self.result.push(']');
                    self.offset += 1;
                    return None;
                }
                _ => {
                    return Some(format!(
                        "unsupport token `{}{}` to end in array",
                        self.chars[self.offset - 1],
                        self.chars[self.offset]
                    ));
                }
            }
        }

        Some("no token to finish array".to_string())
    }

    fn can_not_end_text(&self) -> bool {
        let mut i = self.offset;
        while i < self.chars.len() {
            if self.chars[i].is_whitespace() {
                i += 1;
                continue;
            }
            match self.chars[i] {
                ',' => return false,
                ']' => {
                    i += 1;
                }
                _ => return true,
            }
        }
        false
    }

    fn text(&mut self) -> Option<String> {
        self.result.push('"');
        self.offset += 1;

        while self.offset < self.chars.len() {
            match self.chars[self.offset] {
                '\\' => {
                    self.result.push('\\');
                    self.offset += 1;

                    if self.offset >= self.chars.len() {
                        return Some("no token to scan for text".to_string());
                    }

                    match self.chars[self.offset] {
                        '"' | '\\' | '/' | 'b' | 'f' | 'n' | 'r' | 't' | 'u' => {
                            self.result.push(self.chars[self.offset]);
                            self.offset += 1;
                        }
                        _ => {
                            // case: miss a '\'
                            self.result.push('\\');
                            self.result.push(self.chars[self.offset]);
                            self.offset += 1;
                        }
                    }
                }
                '"' => {
                    self.offset += 1;
                    self.skip_space();
                    if self.offset >= self.chars.len() {
                        self.result.push('"');
                        return None;
                    }

                    if self.can_not_end_text() {
                        // case: ignore an extra '"' and continue to scan
                        continue;
                    }

                    match self.chars[self.offset] {
                        ',' | ']' => {
                            self.result.push('"');
                            return None;
                        }
                        _ => {
                            self.result.push(self.chars[self.offset]);
                            self.offset += 1;
                        }
                    }
                }
                ']' => {
                    self.offset += 1;
                    let offset = self.skip_space_v();
                    if offset >= self.chars.len()
                        || (offset <= self.chars.len() - 1
                            && (self.chars[offset] == ',' || self.chars[offset] == ']'))
                    {
                        self.result.push('"');
                        self.offset -= 1;
                        return None;
                    }

                    self.result.push(']');
                }
                _ => {
                    let c = self.chars[self.offset];
                    if !c.is_control() {
                        self.result.push(c);
                    }
                    self.offset += 1;
                }
            }
        }

        Some("no token to finish text".to_string())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    struct Case {
        input: String,
        output: String,
        err: Option<String>,
    }

    #[test]
    fn valid_json_works() {
        let test_cases: Vec<Case> = vec![
            Case {
                input: r#"[]"#.to_string(),
                output: r#"[]"#.to_string(),
                err: None,
            },
            Case {
                input: r#"[ ] "#.to_string() + "\n",
                output: r#"[]"#.to_string(),
                err: None,
            },
            Case {
                input: r#"[""]"#.to_string(),
                output: r#"[""]"#.to_string(),
                err: None,
            },
            Case {
                input: r#"[" â¤ï¸â€ğŸ”¥ğŸ§‘â€ğŸ¤â€ğŸ§‘"]"#.to_string(),
                output: r#"[" â¤ï¸â€ğŸ”¥ğŸ§‘â€ğŸ¤â€ğŸ§‘"]"#.to_string(),
                err: None,
            },
            Case {
                input: r#"[" \""]"#.to_string(),
                output: r#"[" \""]"#.to_string(),
                err: None,
            },
            Case {
                input: r#"[
                    [],
                    [
                        "Stream:"
                    ],
                    [],
                    [
                        "texts",
                        "Internet Engineering Task Force (IETF)"
                    ]
                ]"#
                .to_string(),
                output: r#"[[],["Stream:"],[],["texts","Internet Engineering Task Force (IETF)"]]"#
                    .to_string(),
                err: None,
            },
        ];

        for case in test_cases {
            match RawJSONArray::new(&case.input).fix_me() {
                Ok(val) => {
                    // println!("FIX_OK: `{}` => `{}`, {}", case.input, val, val.len());
                    assert_eq!(val, case.output);
                }
                Err(err) => {
                    // println!("FIX_ERR:  `{}` => `{}`", case.input, err);
                    assert!(case.err.is_some());
                    assert!(err.contains::<&str>(case.err.unwrap().as_ref()));
                }
            }
        }
    }

    #[test]
    fn fix_invalid_json_works() {
        let test_cases: Vec<Case> = vec![
            Case {
                input: r#"["""]"#.to_string(),
                output: r#"[""]"#.to_string(),
                err: None,
            },
            Case {
                input: r#"["" "]"#.to_string(),
                output: r#"[""]"#.to_string(),
                err: None,
            },
            Case {
                input: r#"["\ Âœ"]"#.to_string(), // with a control char
                output: r#"["\\ "]"#.to_string(),
                err: None,
            },
            Case {
                input: r#"[
                    [],
                    [
                        ""] Stream: ["
                    ],
                    [
                        "Internet Engineering Task Force \(IETF)"
                    ]
                ]"#
                .to_string(),
                output: r#"[[],["] Stream: ["],["Internet Engineering Task Force \\(IETF)"]]"#.to_string(),
                err: None,
            },
            Case {
                input: r#"[
                    [],
                    [
                        ""] Stream: ["
                    ],
                    [
                        "Internet Engineering Task Force \(IETF)"
                ]"#
                .to_string(),
                output: r#"[[],["] Stream: ["],["Internet Engineering Task Force \\(IETF)"]]"#.to_string(),
                err: None,
            },
            Case {
                input: r#"[
                    [],
                    [
                        ""] Stream: ["
                    ],
                    [
                        "Internet Engineering Task Force \(IETF)"
                    ],
                ]"#
                .to_string(),
                output: r#"[[],["] Stream: ["],["Internet Engineering Task Force \\(IETF)"]]"#.to_string(),
                err: None,
            },
            Case {
                input: r#"[
                    [],
                    [
                        ""] Stream: ["
                    ],
                    [
                        "Internet Engineering Task Force \(IETF)1]
                ]"#
                .to_string(),
                output: r#"[[],["] Stream: ["],["Internet Engineering Task Force \\(IETF)1"]]"#.to_string(),
                err: None,
            },
            Case {
                input: r#"[["ä½œä¸ºUTF-8 [","RFC3629",""]ç¼–ç çš„æ–‡æœ¬å­—ç¬¦ä¸²ï¼ˆ","ç¬¬2èŠ‚", "ï¼‰ã€‚å­—ç¬¦ä¸²ä¸­çš„å­—èŠ‚æ•°ç­‰äºå‚æ•°ã€‚åŒ…å«æ— æ•ˆUTF-8åºåˆ—çš„å­—ç¬¦ä¸²æ˜¯æ ¼å¼è‰¯å¥½ä½†æ— æ•ˆçš„ï¼ˆ","ç¬¬1.2èŠ‚", "ï¼‰ã€‚æ­¤ç±»å‹é€‚ç”¨äºéœ€è¦è§£é‡Šæˆ–æ˜¾ç¤ºäººç±»å¯è¯»æ–‡æœ¬çš„ç³»ç»Ÿï¼Œå¹¶å…è®¸åŒºåˆ†ç»“æ„åŒ–å­—èŠ‚å’Œå…·æœ‰æŒ‡å®šæ›²ç›®ï¼ˆUnicodeï¼‰å’Œç¼–ç ï¼ˆUTF-8ï¼‰çš„æ–‡æœ¬ã€‚ä¸JSONç­‰æ ¼å¼ä¸åŒï¼Œæ­¤ç±»å‹ä¸­çš„Unicodeå­—ç¬¦æ°¸è¿œä¸ä¼šè¢«è½¬ä¹‰ã€‚å› æ­¤ï¼Œæ¢è¡Œç¬¦ï¼ˆU+000Aï¼‰å§‹ç»ˆè¡¨ç¤ºä¸ºå­—ç¬¦ä¸²ä¸­çš„å­—èŠ‚0x0aï¼Œè€Œä¸æ˜¯å­—ç¬¦0x5c6eï¼ˆå­—ç¬¦â€œ\â€å’Œâ€œnâ€ï¼‰æˆ–0x5c7530303061ï¼ˆå­—ç¬¦â€œ\â€ï¼Œâ€œuâ€ï¼Œâ€œ0â€ï¼Œâ€œ0â€ï¼Œâ€œ0â€å’Œâ€œaâ€ï¼‰ã€‚","Â¶"]]"#
                .to_string(),
                output: r#"[["ä½œä¸ºUTF-8 [","RFC3629","]ç¼–ç çš„æ–‡æœ¬å­—ç¬¦ä¸²ï¼ˆ","ç¬¬2èŠ‚","ï¼‰ã€‚å­—ç¬¦ä¸²ä¸­çš„å­—èŠ‚æ•°ç­‰äºå‚æ•°ã€‚åŒ…å«æ— æ•ˆUTF-8åºåˆ—çš„å­—ç¬¦ä¸²æ˜¯æ ¼å¼è‰¯å¥½ä½†æ— æ•ˆçš„ï¼ˆ","ç¬¬1.2èŠ‚","ï¼‰ã€‚æ­¤ç±»å‹é€‚ç”¨äºéœ€è¦è§£é‡Šæˆ–æ˜¾ç¤ºäººç±»å¯è¯»æ–‡æœ¬çš„ç³»ç»Ÿï¼Œå¹¶å…è®¸åŒºåˆ†ç»“æ„åŒ–å­—èŠ‚å’Œå…·æœ‰æŒ‡å®šæ›²ç›®ï¼ˆUnicodeï¼‰å’Œç¼–ç ï¼ˆUTF-8ï¼‰çš„æ–‡æœ¬ã€‚ä¸JSONç­‰æ ¼å¼ä¸åŒï¼Œæ­¤ç±»å‹ä¸­çš„Unicodeå­—ç¬¦æ°¸è¿œä¸ä¼šè¢«è½¬ä¹‰ã€‚å› æ­¤ï¼Œæ¢è¡Œç¬¦ï¼ˆU+000Aï¼‰å§‹ç»ˆè¡¨ç¤ºä¸ºå­—ç¬¦ä¸²ä¸­çš„å­—èŠ‚0x0aï¼Œè€Œä¸æ˜¯å­—ç¬¦0x5c6eï¼ˆå­—ç¬¦â€œ\\â€å’Œâ€œnâ€ï¼‰æˆ–0x5c7530303061ï¼ˆå­—ç¬¦â€œ\\â€ï¼Œâ€œuâ€ï¼Œâ€œ0â€ï¼Œâ€œ0â€ï¼Œâ€œ0â€å’Œâ€œaâ€ï¼‰ã€‚","Â¶"]]"#.to_string(),
                err: None,
            },
            Case {
                input: r#"[["ç‰¹å®šæ•°æ®æ¨¡å‹è¿˜å¯ä»¥ä¸ºæ˜ å°„é”®å’Œç¼–ç å™¨è‡ªç”±åº¦æŒ‡å®šå€¼ç­‰æ•ˆæ€§ï¼ˆåŒ…æ‹¬ä¸åŒç±»å‹çš„å€¼ï¼‰ã€‚ä¾‹å¦‚ï¼Œåœ¨é€šç”¨æ•°æ®æ¨¡å‹ä¸­ï¼Œæœ‰æ•ˆçš„æ˜ å°„å¯ä»¥åŒæ—¶å…·æœ‰ ","0",", ","0.0",", ä½œä¸ºé”®ï¼Œå¹¶ä¸”ç¼–ç å™¨ä¸å¾—å°† ","0.0", ç¼–ç ä¸ºæ•´æ•°ï¼ˆä¸»ç±»å‹ 0ï¼Œ ","ç¬¬ 3.1 èŠ‚",ï¼‰ã€‚ä½†æ˜¯ï¼Œå¦‚æœç‰¹å®šæ•°æ®æ¨¡å‹å£°æ˜æ•´æ•°å€¼å’Œæµ®ç‚¹è¡¨ç¤ºçš„æ•´æ•°å€¼ç­‰æ•ˆï¼Œåˆ™åœ¨å•ä¸ªæ˜ å°„ä¸­ä½¿ç”¨ä¸¤ä¸ªæ˜ å°„é”® ","0",", ","0.0",", å°†è¢«è§†ä¸ºé‡å¤ï¼Œå³ä½¿å®ƒä»¬è¢«ç¼–ç ä¸ºä¸åŒçš„ä¸»ç±»å‹ï¼Œå› æ­¤æ— æ•ˆï¼›ç¼–ç å™¨å¯ä»¥å°†æ•´æ•°å€¼çš„æµ®ç‚¹æ•°ç¼–ç ä¸ºæ•´æ•°æˆ–åä¹‹äº¦ç„¶ï¼Œå¯èƒ½æ˜¯ä¸ºäº†èŠ‚çœç¼–ç å­—èŠ‚ã€‚","Â¶"],["3. ","CBOR ç¼–ç çš„è§„èŒƒ"],["CBOR æ•°æ®é¡¹ï¼ˆ","ç¬¬ 2 èŠ‚",") è¢«ç¼–ç ä¸ºæˆ–ä»æºå¸¦æœ‰å½¢å¼è‰¯å¥½çš„ç¼–ç æ•°æ®é¡¹çš„å­—èŠ‚å­—ç¬¦ä¸²ä¸­è§£ç ï¼Œå¦‚æœ¬èŠ‚æ‰€è¿°ã€‚ç¼–ç æ€»ç»“åœ¨ ","é™„å½• B"," ä¸­çš„ ","è¡¨ 7"," ä¸­ï¼Œç”±åˆå§‹å­—èŠ‚ç´¢å¼•ã€‚ç¼–ç å™¨å¿…é¡»ä»…ç”Ÿæˆå½¢å¼è‰¯å¥½çš„ç¼–ç æ•°æ®é¡¹ã€‚å½“è§£ç å™¨é‡åˆ°ä¸æ˜¯å½¢å¼è‰¯å¥½çš„ç¼–ç  CBOR æ•°æ®é¡¹çš„è¾“å…¥æ—¶ï¼Œè§£ç å™¨ä¸å¾—è¿”å›å·²è§£ç çš„æ•°æ®é¡¹ï¼ˆè¿™å¹¶ä¸å½±å“å¯èƒ½æä¾›ä¸€äº›æ¥è‡ªæŸåçš„ç¼–ç  CBOR æ•°æ®é¡¹çš„ä¿¡æ¯çš„è¯Šæ–­å’Œæ¢å¤å·¥å…·çš„æœ‰ç”¨æ€§ï¼‰ã€‚","Â¶"],["æ¯ä¸ªç¼–ç æ•°æ®é¡¹çš„åˆå§‹å­—èŠ‚éƒ½åŒ…å«æœ‰å…³ä¸»ç±»å‹ï¼ˆé«˜ 3 ä½ï¼Œå¦‚ ","ç¬¬ 3.1 èŠ‚"," ä¸­æ‰€è¿°ï¼‰å’Œå…¶ä»–ä¿¡æ¯ï¼ˆä½ 5 ä½ï¼‰çš„ä¿¡æ¯ã€‚é™¤äº†å°‘æ•°ä¾‹å¤–ï¼Œé™„åŠ ä¿¡æ¯çš„å€¼æè¿°å¦‚ä½•åŠ è½½æ— ç¬¦å·æ•´æ•°â€œå‚æ•°â€ï¼š","Â¶"],["å°äº 24ï¼š"],["å‚æ•°çš„å€¼æ˜¯é™„åŠ ä¿¡æ¯çš„å€¼ã€‚","Â¶"],["24ã€25ã€26 æˆ– 27ï¼š"],["å‚æ•°çš„å€¼åˆ†åˆ«ä¿å­˜åœ¨ä»¥ä¸‹ 1ã€2ã€4 æˆ– 8 ä¸ªå­—èŠ‚ä¸­ï¼Œä»¥ç½‘ç»œå­—èŠ‚é¡ºåºæ’åˆ—ã€‚å¯¹äºä¸»ç±»å‹ 7 å’Œé™„åŠ ä¿¡æ¯å€¼ 25ã€26ã€27ï¼Œè¿™äº›å­—èŠ‚ä¸ç”¨ä½œæ•´æ•°å‚æ•°ï¼Œè€Œç”¨ä½œæµ®ç‚¹å€¼ï¼ˆè¯·å‚è§ ","ç¬¬ 3.3 èŠ‚",ï¼‰ã€‚","Â¶"],["28ã€29ã€30ï¼š"],["è¿™äº›å€¼ä¿ç•™ç”¨äºå°†æ¥æ·»åŠ åˆ° CBOR æ ¼å¼ä¸­ã€‚åœ¨ CBOR çš„å½“å‰ç‰ˆæœ¬ä¸­ï¼Œç¼–ç é¡¹ä¸æ˜¯å½¢å¼è‰¯å¥½çš„ã€‚","Â¶"],["31ï¼š"],["ä¸æ´¾ç”Ÿå‚æ•°å€¼ã€‚å¦‚æœä¸»ç±»å‹ä¸º 0ã€1 æˆ– 6ï¼Œåˆ™ç¼–ç é¡¹ä¸æ˜¯å½¢å¼è‰¯å¥½çš„ã€‚å¯¹äºä¸»ç±»å‹ 2 åˆ° 5ï¼Œé¡¹ç›®çš„é•¿åº¦æ˜¯ä¸ç¡®å®šçš„ï¼Œå¯¹äºä¸»ç±»å‹ 7ï¼Œå­—èŠ‚æ ¹æœ¬ä¸æ„æˆæ•°æ®é¡¹ï¼Œè€Œæ˜¯ç»ˆæ­¢æ— é™é•¿åº¦é¡¹ï¼›æ‰€æœ‰è¿™äº›éƒ½åœ¨ ","ç¬¬ 3.2 èŠ‚"," ä¸­æè¿°ã€‚","Â¶"],["ç¼–ç æ•°æ®é¡¹çš„åˆå§‹å­—èŠ‚å’Œä»»ä½•å…¶ä»–å­—èŠ‚ç”¨äºæ„é€ å‚æ•°çš„é›†åˆç§°ä¸ºæ•°æ®é¡¹çš„å¤´éƒ¨ã€‚","Â¶"],["æ­¤å‚æ•°çš„å«ä¹‰å–å†³äºä¸»ç±»å‹ã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸»ç±»å‹ 0 ä¸­ï¼Œå‚æ•°æ˜¯æ•°æ®é¡¹æœ¬èº«çš„å€¼ï¼ˆåœ¨ä¸»ç±»å‹ 1 ä¸­ï¼Œæ•°æ®é¡¹çš„å€¼æ˜¯ä»å‚æ•°è®¡ç®—å‡ºçš„ï¼‰ï¼›åœ¨ä¸»ç±»å‹ 2 å’Œ 3 ä¸­ï¼Œå®ƒç»™å‡ºäº†éšåçš„å­—ç¬¦ä¸²æ•°æ®çš„å­—èŠ‚é•¿åº¦ï¼›åœ¨ä¸»ç±»å‹ 4 å’Œ 5 ä¸­ï¼Œå®ƒç”¨äºç¡®å®šæ‰€åŒ…å«çš„æ•°æ®é¡¹çš„æ•°é‡ã€‚","Â¶"],["å¦‚æœç¼–ç çš„å­—èŠ‚åºåˆ—åœ¨æ•°æ®é¡¹ç»“æŸä¹‹å‰ç»“æŸï¼Œåˆ™è¯¥é¡¹ä¸æ˜¯å½¢å¼è‰¯å¥½çš„ã€‚å¦‚æœç¼–ç çš„å­—èŠ‚åºåˆ—åœ¨æœ€å¤–å±‚ç¼–ç é¡¹è§£ç åä»æœ‰å‰©ä½™å­—èŠ‚ï¼Œåˆ™è¯¥ç¼–ç ä¸æ˜¯å•ä¸ªå½¢å¼è‰¯å¥½çš„ CBOR é¡¹ã€‚æ ¹æ®åº”ç”¨ç¨‹åºï¼Œè§£ç å™¨å¯ä»¥å°†ç¼–ç è§†ä¸ºä¸æ˜¯å½¢å¼è‰¯å¥½çš„ï¼Œæˆ–è€…ä»…å°†å‰©ä½™å­—èŠ‚çš„å¼€å§‹æ ‡è¯†ç»™åº”ç”¨ç¨‹åºã€‚","Â¶"],["CBOR è§£ç å™¨å®ç°å¯ä»¥åŸºäºå…·æœ‰åˆå§‹å­—èŠ‚çš„æ‰€æœ‰ 256 ä¸ªå®šä¹‰å€¼çš„è·³è½¬è¡¨ï¼ˆ","è¡¨ 7",ï¼‰ã€‚çº¦æŸå®ç°ä¸­çš„è§£ç å™¨å¯ä»¥ä½¿ç”¨åˆå§‹å­—èŠ‚å’Œåç»­å­—èŠ‚çš„ç»“æ„è¿›è¡Œæ›´ç´§å‡‘çš„ä»£ç ï¼ˆæœ‰å…³æ­¤ä»£ç çš„å¤§è‡´å°è±¡ï¼Œè¯·å‚è§ ","é™„å½• C","ï¼‰ã€‚","Â¶"],["3.1. ","ä¸»ç±»å‹"],["ä»¥ä¸‹åˆ—å‡ºäº†ä¸»ç±»å‹åŠå…¶å…³è”çš„é™„åŠ ä¿¡æ¯å’Œå…¶ä»–å­—èŠ‚ã€‚","Â¶"],["ä¸»ç±»å‹ 0ï¼š"],["èŒƒå›´åœ¨ 0..2","64","-1 å†…çš„æ— ç¬¦å·æ•´æ•°ã€‚ç¼–ç é¡¹çš„å€¼æ˜¯å‚æ•°æœ¬èº«ã€‚ä¾‹å¦‚ï¼Œæ•´æ•° 10 è¡¨ç¤ºä¸ºä¸€ä¸ªå­—èŠ‚ 0b000_01010ï¼ˆä¸»ç±»å‹ 0ï¼Œé™„åŠ ä¿¡æ¯ 10ï¼‰ã€‚æ•´æ•° 500 å°†æ˜¯ 0b000_11001ï¼ˆä¸»ç±»å‹ 0ï¼Œé™„åŠ ä¿¡æ¯ 25ï¼‰åè·Ÿä¸¤ä¸ªå­—èŠ‚ 0x01f4ï¼Œå³åè¿›åˆ¶ä¸­çš„ 500ã€‚","Â¶"],["ä¸»ç±»å‹ 1ï¼š"],["èŒƒå›´åœ¨ -2","64","..-1 å†…çš„è´Ÿæ•´æ•°ã€‚é¡¹ç›®çš„å€¼ä¸º -1 å‡å»å‚æ•°ã€‚ä¾‹å¦‚ï¼Œæ•´æ•° -500 å°†æ˜¯ 0b001_11001ï¼ˆä¸»ç±»å‹ 1ï¼Œé™„åŠ ä¿¡æ¯ 25ï¼‰åè·Ÿä¸¤ä¸ªå­—èŠ‚ 0x01f3ï¼Œå³åè¿›åˆ¶ä¸­çš„ 499ã€‚","Â¶"]]"#.to_string(),
                output: r#"[["ç‰¹å®šæ•°æ®æ¨¡å‹è¿˜å¯ä»¥ä¸ºæ˜ å°„é”®å’Œç¼–ç å™¨è‡ªç”±åº¦æŒ‡å®šå€¼ç­‰æ•ˆæ€§ï¼ˆåŒ…æ‹¬ä¸åŒç±»å‹çš„å€¼ï¼‰ã€‚ä¾‹å¦‚ï¼Œåœ¨é€šç”¨æ•°æ®æ¨¡å‹ä¸­ï¼Œæœ‰æ•ˆçš„æ˜ å°„å¯ä»¥åŒæ—¶å…·æœ‰ ","0",", ","0.0",", ä½œä¸ºé”®ï¼Œå¹¶ä¸”ç¼–ç å™¨ä¸å¾—å°† ","0.0","ç¼–ç ä¸ºæ•´æ•°ï¼ˆä¸»ç±»å‹ 0ï¼Œ ","ç¬¬ 3.1 èŠ‚","ï¼‰ã€‚ä½†æ˜¯ï¼Œå¦‚æœç‰¹å®šæ•°æ®æ¨¡å‹å£°æ˜æ•´æ•°å€¼å’Œæµ®ç‚¹è¡¨ç¤ºçš„æ•´æ•°å€¼ç­‰æ•ˆï¼Œåˆ™åœ¨å•ä¸ªæ˜ å°„ä¸­ä½¿ç”¨ä¸¤ä¸ªæ˜ å°„é”® ","0",", ","0.0",", å°†è¢«è§†ä¸ºé‡å¤ï¼Œå³ä½¿å®ƒä»¬è¢«ç¼–ç ä¸ºä¸åŒçš„ä¸»ç±»å‹ï¼Œå› æ­¤æ— æ•ˆï¼›ç¼–ç å™¨å¯ä»¥å°†æ•´æ•°å€¼çš„æµ®ç‚¹æ•°ç¼–ç ä¸ºæ•´æ•°æˆ–åä¹‹äº¦ç„¶ï¼Œå¯èƒ½æ˜¯ä¸ºäº†èŠ‚çœç¼–ç å­—èŠ‚ã€‚","Â¶"],["3. ","CBOR ç¼–ç çš„è§„èŒƒ"],["CBOR æ•°æ®é¡¹ï¼ˆ","ç¬¬ 2 èŠ‚",") è¢«ç¼–ç ä¸ºæˆ–ä»æºå¸¦æœ‰å½¢å¼è‰¯å¥½çš„ç¼–ç æ•°æ®é¡¹çš„å­—èŠ‚å­—ç¬¦ä¸²ä¸­è§£ç ï¼Œå¦‚æœ¬èŠ‚æ‰€è¿°ã€‚ç¼–ç æ€»ç»“åœ¨ ","é™„å½• B"," ä¸­çš„ ","è¡¨ 7"," ä¸­ï¼Œç”±åˆå§‹å­—èŠ‚ç´¢å¼•ã€‚ç¼–ç å™¨å¿…é¡»ä»…ç”Ÿæˆå½¢å¼è‰¯å¥½çš„ç¼–ç æ•°æ®é¡¹ã€‚å½“è§£ç å™¨é‡åˆ°ä¸æ˜¯å½¢å¼è‰¯å¥½çš„ç¼–ç  CBOR æ•°æ®é¡¹çš„è¾“å…¥æ—¶ï¼Œè§£ç å™¨ä¸å¾—è¿”å›å·²è§£ç çš„æ•°æ®é¡¹ï¼ˆè¿™å¹¶ä¸å½±å“å¯èƒ½æä¾›ä¸€äº›æ¥è‡ªæŸåçš„ç¼–ç  CBOR æ•°æ®é¡¹çš„ä¿¡æ¯çš„è¯Šæ–­å’Œæ¢å¤å·¥å…·çš„æœ‰ç”¨æ€§ï¼‰ã€‚","Â¶"],["æ¯ä¸ªç¼–ç æ•°æ®é¡¹çš„åˆå§‹å­—èŠ‚éƒ½åŒ…å«æœ‰å…³ä¸»ç±»å‹ï¼ˆé«˜ 3 ä½ï¼Œå¦‚ ","ç¬¬ 3.1 èŠ‚"," ä¸­æ‰€è¿°ï¼‰å’Œå…¶ä»–ä¿¡æ¯ï¼ˆä½ 5 ä½ï¼‰çš„ä¿¡æ¯ã€‚é™¤äº†å°‘æ•°ä¾‹å¤–ï¼Œé™„åŠ ä¿¡æ¯çš„å€¼æè¿°å¦‚ä½•åŠ è½½æ— ç¬¦å·æ•´æ•°â€œå‚æ•°â€ï¼š","Â¶"],["å°äº 24ï¼š"],["å‚æ•°çš„å€¼æ˜¯é™„åŠ ä¿¡æ¯çš„å€¼ã€‚","Â¶"],["24ã€25ã€26 æˆ– 27ï¼š"],["å‚æ•°çš„å€¼åˆ†åˆ«ä¿å­˜åœ¨ä»¥ä¸‹ 1ã€2ã€4 æˆ– 8 ä¸ªå­—èŠ‚ä¸­ï¼Œä»¥ç½‘ç»œå­—èŠ‚é¡ºåºæ’åˆ—ã€‚å¯¹äºä¸»ç±»å‹ 7 å’Œé™„åŠ ä¿¡æ¯å€¼ 25ã€26ã€27ï¼Œè¿™äº›å­—èŠ‚ä¸ç”¨ä½œæ•´æ•°å‚æ•°ï¼Œè€Œç”¨ä½œæµ®ç‚¹å€¼ï¼ˆè¯·å‚è§ ","ç¬¬ 3.3 èŠ‚","ï¼‰ã€‚","Â¶"],["28ã€29ã€30ï¼š"],["è¿™äº›å€¼ä¿ç•™ç”¨äºå°†æ¥æ·»åŠ åˆ° CBOR æ ¼å¼ä¸­ã€‚åœ¨ CBOR çš„å½“å‰ç‰ˆæœ¬ä¸­ï¼Œç¼–ç é¡¹ä¸æ˜¯å½¢å¼è‰¯å¥½çš„ã€‚","Â¶"],["31ï¼š"],["ä¸æ´¾ç”Ÿå‚æ•°å€¼ã€‚å¦‚æœä¸»ç±»å‹ä¸º 0ã€1 æˆ– 6ï¼Œåˆ™ç¼–ç é¡¹ä¸æ˜¯å½¢å¼è‰¯å¥½çš„ã€‚å¯¹äºä¸»ç±»å‹ 2 åˆ° 5ï¼Œé¡¹ç›®çš„é•¿åº¦æ˜¯ä¸ç¡®å®šçš„ï¼Œå¯¹äºä¸»ç±»å‹ 7ï¼Œå­—èŠ‚æ ¹æœ¬ä¸æ„æˆæ•°æ®é¡¹ï¼Œè€Œæ˜¯ç»ˆæ­¢æ— é™é•¿åº¦é¡¹ï¼›æ‰€æœ‰è¿™äº›éƒ½åœ¨ ","ç¬¬ 3.2 èŠ‚"," ä¸­æè¿°ã€‚","Â¶"],["ç¼–ç æ•°æ®é¡¹çš„åˆå§‹å­—èŠ‚å’Œä»»ä½•å…¶ä»–å­—èŠ‚ç”¨äºæ„é€ å‚æ•°çš„é›†åˆç§°ä¸ºæ•°æ®é¡¹çš„å¤´éƒ¨ã€‚","Â¶"],["æ­¤å‚æ•°çš„å«ä¹‰å–å†³äºä¸»ç±»å‹ã€‚ä¾‹å¦‚ï¼Œåœ¨ä¸»ç±»å‹ 0 ä¸­ï¼Œå‚æ•°æ˜¯æ•°æ®é¡¹æœ¬èº«çš„å€¼ï¼ˆåœ¨ä¸»ç±»å‹ 1 ä¸­ï¼Œæ•°æ®é¡¹çš„å€¼æ˜¯ä»å‚æ•°è®¡ç®—å‡ºçš„ï¼‰ï¼›åœ¨ä¸»ç±»å‹ 2 å’Œ 3 ä¸­ï¼Œå®ƒç»™å‡ºäº†éšåçš„å­—ç¬¦ä¸²æ•°æ®çš„å­—èŠ‚é•¿åº¦ï¼›åœ¨ä¸»ç±»å‹ 4 å’Œ 5 ä¸­ï¼Œå®ƒç”¨äºç¡®å®šæ‰€åŒ…å«çš„æ•°æ®é¡¹çš„æ•°é‡ã€‚","Â¶"],["å¦‚æœç¼–ç çš„å­—èŠ‚åºåˆ—åœ¨æ•°æ®é¡¹ç»“æŸä¹‹å‰ç»“æŸï¼Œåˆ™è¯¥é¡¹ä¸æ˜¯å½¢å¼è‰¯å¥½çš„ã€‚å¦‚æœç¼–ç çš„å­—èŠ‚åºåˆ—åœ¨æœ€å¤–å±‚ç¼–ç é¡¹è§£ç åä»æœ‰å‰©ä½™å­—èŠ‚ï¼Œåˆ™è¯¥ç¼–ç ä¸æ˜¯å•ä¸ªå½¢å¼è‰¯å¥½çš„ CBOR é¡¹ã€‚æ ¹æ®åº”ç”¨ç¨‹åºï¼Œè§£ç å™¨å¯ä»¥å°†ç¼–ç è§†ä¸ºä¸æ˜¯å½¢å¼è‰¯å¥½çš„ï¼Œæˆ–è€…ä»…å°†å‰©ä½™å­—èŠ‚çš„å¼€å§‹æ ‡è¯†ç»™åº”ç”¨ç¨‹åºã€‚","Â¶"],["CBOR è§£ç å™¨å®ç°å¯ä»¥åŸºäºå…·æœ‰åˆå§‹å­—èŠ‚çš„æ‰€æœ‰ 256 ä¸ªå®šä¹‰å€¼çš„è·³è½¬è¡¨ï¼ˆ","è¡¨ 7","ï¼‰ã€‚çº¦æŸå®ç°ä¸­çš„è§£ç å™¨å¯ä»¥ä½¿ç”¨åˆå§‹å­—èŠ‚å’Œåç»­å­—èŠ‚çš„ç»“æ„è¿›è¡Œæ›´ç´§å‡‘çš„ä»£ç ï¼ˆæœ‰å…³æ­¤ä»£ç çš„å¤§è‡´å°è±¡ï¼Œè¯·å‚è§ ","é™„å½• C","ï¼‰ã€‚","Â¶"],["3.1. ","ä¸»ç±»å‹"],["ä»¥ä¸‹åˆ—å‡ºäº†ä¸»ç±»å‹åŠå…¶å…³è”çš„é™„åŠ ä¿¡æ¯å’Œå…¶ä»–å­—èŠ‚ã€‚","Â¶"],["ä¸»ç±»å‹ 0ï¼š"],["èŒƒå›´åœ¨ 0..2","64","-1 å†…çš„æ— ç¬¦å·æ•´æ•°ã€‚ç¼–ç é¡¹çš„å€¼æ˜¯å‚æ•°æœ¬èº«ã€‚ä¾‹å¦‚ï¼Œæ•´æ•° 10 è¡¨ç¤ºä¸ºä¸€ä¸ªå­—èŠ‚ 0b000_01010ï¼ˆä¸»ç±»å‹ 0ï¼Œé™„åŠ ä¿¡æ¯ 10ï¼‰ã€‚æ•´æ•° 500 å°†æ˜¯ 0b000_11001ï¼ˆä¸»ç±»å‹ 0ï¼Œé™„åŠ ä¿¡æ¯ 25ï¼‰åè·Ÿä¸¤ä¸ªå­—èŠ‚ 0x01f4ï¼Œå³åè¿›åˆ¶ä¸­çš„ 500ã€‚","Â¶"],["ä¸»ç±»å‹ 1ï¼š"],["èŒƒå›´åœ¨ -2","64","..-1 å†…çš„è´Ÿæ•´æ•°ã€‚é¡¹ç›®çš„å€¼ä¸º -1 å‡å»å‚æ•°ã€‚ä¾‹å¦‚ï¼Œæ•´æ•° -500 å°†æ˜¯ 0b001_11001ï¼ˆä¸»ç±»å‹ 1ï¼Œé™„åŠ ä¿¡æ¯ 25ï¼‰åè·Ÿä¸¤ä¸ªå­—èŠ‚ 0x01f3ï¼Œå³åè¿›åˆ¶ä¸­çš„ 499ã€‚","Â¶"]]"#.to_string(),
                err: None,
            },
        ];

        for case in test_cases {
            match RawJSONArray::new(&case.input).fix_me() {
                Ok(val) => {
                    // println!("FIX_OK: `{}` => `{}`, {}", case.input, val, val.len());
                    assert_eq!(val, case.output);
                }
                Err(err) => {
                    println!("FIX_ERR:  `{}` => `{}`", case.input, err);
                    assert!(case.err.is_some());
                    assert!(err.contains::<&str>(case.err.unwrap().as_ref()));
                }
            }
        }
    }
}
